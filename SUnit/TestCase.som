TestCase = (
    | testSelector runner failed cleanupAndReturnBlock |
    
    selector       = ( ^ testSelector )
    selector: aSym = ( testSelector := aSym )
    
    "asserting"
    assert: aBoolean = ( aBoolean ifFalse: [self signalFailure: 'Assertion failed'] )

    assert: aBooleanOrBlock description: aString = (
        aBooleanOrBlock value ifFalse: [
            self signalFailure: aString
        ]
    )
    
    assert: expected equals: actual = (
        ^ self
            assert: (expected = actual)
            description: (self comparingStringBetween: expected and: actual)
    )
    
    deny: aBoolean = (
        self assert: aBoolean not
    )
    
    deny: aBooleanOrBlock description: aString = (
        self assert: aBooleanOrBlock value not description: aString
    )
    
    signalFailure: aString = (
        failed := true.
        runner fail: self class name asString + '>>#' + testSelector asString 
            because: aString.
        cleanupAndReturnBlock value
    )
    
    comparingStringBetween: expected and: actual = (
        ^ 'Expected ' + expected asString +
          ' but was ' + actual asString + '.'
    )
    
    "running"
    run: aRunner = (
        runner := aRunner.
        failed := false.
        
        cleanupAndReturnBlock := [^self tearDown].
        
        self setUp.
        self performTest.
        
        runner passed: self class name asString + '>>#' + testSelector asString.
        cleanupAndReturnBlock value.
    )
    
    setUp    = ()
    tearDown = ()
    
    performTest  = ( self perform: testSelector )
    
    ----
    
    for: aSelector = (
        | case |
        case := self new.
        case selector: aSelector.
        ^ case
    )
    
    tests = (
        | tests |
        tests := Vector new: self methods length.
        self methods do: [:m |
            (m signature asString beginsWith: 'test') ifTrue: [
                tests append: (self for: m signature).
            ].
        ].
        
        ^ tests
    )
)